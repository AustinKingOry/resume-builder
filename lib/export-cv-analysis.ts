// generateFeedbackFromAnalysis.ts
import {
    Document,
    Packer,
    Paragraph,
    TextRun,
    HeadingLevel,
    AlignmentType,
    Table,
    TableRow,
    TableCell,
    WidthType,
    BorderStyle,
    ImageRun,
    Header,
    Footer,
    PageNumber,
  } from "docx";
  
  /**
   * The CVAnalysisResult interface you provided
   */
  export interface CVAnalysisResult {
    id: string;
    overall: string;
    feedback: Array<{
      title: string;
      content: string;
      category: string;
      severity: "low" | "medium" | "high";
      tip?: string;
      kenyanContext?: string;
    }>;
    marketReadiness: {
      score: number;
      strengths: string[];
      priorities: string[];
    };
    kenyanJobMarketTips: string[];
    processingTime: number;
    metadata: {
      fileName: string;
      fileSize: number;
      fileType: string;
      pageCount?: number;
      wordCount: number;
    };
    usage?: {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
    };
    finishReason?: string;
    createdAt: string;
    isComplete: boolean;
  }
  
  /** Output */
  export type GenerateResult = {
    buffer: Buffer;
    filename: string;
  };
  
  /** Options */
  export type GenerateOptions = {
    author?: string;
    filename?: string;
    logoBase64?: string | null;
    logoWidthPx?: number;
    logoHeightPx?: number;
  };
  
  /** Small helpers */
  const sanitize = (s?: string | null) => (typeof s === "string" ? s : "");
  const fmtNum = (n?: number | null) => (typeof n === "number" ? String(n) : "—");
  
  /** Map severity to color hex (docx expects hex without #) */
  const severityColor = (s: "low" | "medium" | "high") =>
    s === "high" ? "B00020" : s === "medium" ? "D97F00" : "006400";
  
  /**
   * generateFeedbackFromAnalysis
   * - Accepts a CVAnalysisResult and returns a Buffer + filename for download
   */
  export async function generateFeedbackFromAnalysis(
    analysis: CVAnalysisResult,
    options: GenerateOptions = {}
  ): Promise<GenerateResult> {
    if (!analysis) throw new Error("No analysis provided");
  
    const {
      author = "Kazikit Roast My CV",
      filename =
        (analysis.metadata?.fileName
          ? `${analysis.metadata.fileName.replace(/\.[^/.]+$/, "")}-kazikit-feedback.docx`
          : `${analysis.id}-kazikit-feedback.docx`),
      logoBase64 = null,
      logoWidthPx = 120,
      logoHeightPx,
    } = options;
  
    try {
      const doc = new Document({
        creator: author,
        title: `${analysis.metadata?.fileName ?? "CV"} - Kazikit Feedback`,
        description: `Feedback generated by Kazikit for ${analysis.metadata?.fileName ?? analysis.id}`,
        styles: {
          default: {
            run: {
              font: "Calibri",
              size: 22, // 11pt
            },
          },
        },
      });
  
      // Header (logo-left + title-right)
      const headerChildren = [];
      if (logoBase64) {
        const img = new ImageRun({
          data: Buffer.from(logoBase64, "base64"),
          transformation: {
            width: logoWidthPx,
            height: logoHeightPx ?? Math.round((logoWidthPx * 40) / 120),
          },
        });
        headerChildren.push(new Paragraph({ children: [img], alignment: AlignmentType.LEFT }));
      }
      headerChildren.push(
        new Paragraph({
          children: [
            new TextRun({ text: "Kazikit — Roast My CV", bold: true, size: 26 }),
            new TextRun({ text: `  |  ${analysis.metadata?.fileName ?? analysis.id}`, size: 22 }),
          ],
          alignment: AlignmentType.RIGHT,
        })
      );
  
      doc.addSection({
        headers: { default: new Header({ children: headerChildren }) },
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({ text: "Kazikit • ", size: 20 }),
                  new TextRun({ children: [PageNumber.CURRENT], size: 20 }),
                  new TextRun({ text: " / ", size: 20 }),
                  new TextRun({ children: [PageNumber.TOTAL_PAGES], size: 20 }),
                ],
              }),
            ],
          }),
        },
        children: [], // body appended below
      });
  
      // Build metadata table rows
      const meta = analysis.metadata || ({} as any);
      const usage = analysis.usage;
  
      const metadataTable = new Table({
        width: { size: 100, type: WidthType.PERCENTAGE },
        rows: [
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "File name", bold: true })] }),
              new TableCell({ children: [new Paragraph(sanitize(meta.fileName) || "—")] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "File size (bytes)", bold: true })] }),
              new TableCell({ children: [new Paragraph(fmtNum(meta.fileSize))] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "File type", bold: true })] }),
              new TableCell({ children: [new Paragraph(sanitize(meta.fileType) || "—")] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Page count", bold: true })] }),
              new TableCell({ children: [new Paragraph(fmtNum(meta.pageCount))] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Word count", bold: true })] }),
              new TableCell({ children: [new Paragraph(fmtNum(meta.wordCount))] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Processing time (ms)", bold: true })] }),
              new TableCell({ children: [new Paragraph(fmtNum(analysis.processingTime))] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Created at", bold: true })] }),
              new TableCell({ children: [new Paragraph(sanitize(analysis.createdAt))] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Complete", bold: true })] }),
              new TableCell({ children: [new Paragraph(analysis.isComplete ? "Yes" : "No")] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Finish reason", bold: true })] }),
              new TableCell({ children: [new Paragraph(sanitize(analysis.finishReason) || "—")] }),
            ],
          }),
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ text: "Usage (tokens)", bold: true })] }),
              new TableCell({
                children: [
                  new Paragraph(
                    usage
                      ? `prompt: ${fmtNum(usage.promptTokens)}, completion: ${fmtNum(
                          usage.completionTokens
                        )}, total: ${fmtNum(usage.totalTokens)}`
                      : "—"
                  ),
                ],
              }),
            ],
          }),
        ],
      });
  
      // Body content assembly
      const bodyChildren: (Paragraph | Table)[] = [];
  
      // Title & overall verdict
      bodyChildren.push(
        new Paragraph({
          text: "Kazikit — Roast My CV Feedback",
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          spacing: { after: 200 },
        })
      );
  
      bodyChildren.push(new Paragraph({ children: [], spacing: { after: 120 } }));
      bodyChildren.push(metadataTable);
  
      // Overall verdict
      bodyChildren.push(
        new Paragraph({
          text: "Overall Verdict",
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 240, after: 120 },
        })
      );
      bodyChildren.push(
        new Paragraph({
          children: [new TextRun({ text: sanitize(analysis.overall), size: 24 })],
        })
      );
  
      // Market Readiness
      bodyChildren.push(
        new Paragraph({
          text: `Market Readiness — Score: ${fmtNum(analysis.marketReadiness?.score)}`,
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 240, after: 120 },
        })
      );
      // strengths
      if (analysis.marketReadiness?.strengths?.length) {
        bodyChildren.push(new Paragraph({ text: "Strengths", heading: HeadingLevel.HEADING_3 }));
        for (const s of analysis.marketReadiness.strengths) {
          bodyChildren.push(new Paragraph({ children: [new TextRun({ text: "• " + sanitize(s) })] }));
        }
      }
      // priorities
      if (analysis.marketReadiness?.priorities?.length) {
        bodyChildren.push(new Paragraph({ text: "Priorities", heading: HeadingLevel.HEADING_3 }));
        for (const p of analysis.marketReadiness.priorities) {
          bodyChildren.push(new Paragraph({ children: [new TextRun({ text: "• " + sanitize(p) })] }));
        }
      }
  
      // Kenyan job market tips
      if (analysis.kenyanJobMarketTips?.length) {
        bodyChildren.push(new Paragraph({ text: "Kenyan Job Market Tips", heading: HeadingLevel.HEADING_2 }));
        for (const tip of analysis.kenyanJobMarketTips) {
          bodyChildren.push(new Paragraph({ children: [new TextRun({ text: "• " + sanitize(tip) })] }));
        }
      }
  
      // Detailed feedback grouped by category
      if (analysis.feedback && analysis.feedback.length) {
        bodyChildren.push(new Paragraph({ text: "Detailed Feedback", heading: HeadingLevel.HEADING_2 }));
        // Option: group by category
        const grouped = analysis.feedback.reduce<Record<string, typeof analysis.feedback>>((acc, item) => {
          (acc[item.category] ||= []).push(item);
          return acc;
        }, {});
  
        for (const [category, items] of Object.entries(grouped)) {
          bodyChildren.push(
            new Paragraph({
              text: category,
              heading: HeadingLevel.HEADING_3,
              spacing: { before: 180, after: 80 },
            })
          );
  
          for (const it of items) {
            // severity badge (colored text)
            const severityRun = new TextRun({
              text: `[${it.severity.toUpperCase()}] `,
              bold: true,
              color: severityColor(it.severity),
            });
  
            bodyChildren.push(
              new Paragraph({
                children: [
                  severityRun,
                  new TextRun({ text: sanitize(it.title), bold: true }),
                ],
              })
            );
  
            // content
            bodyChildren.push(new Paragraph({ children: [new TextRun({ text: sanitize(it.content) })] }));
  
            // optional tip and kenyanContext
            if (it.tip) {
              bodyChildren.push(
                new Paragraph({
                  children: [new TextRun({ text: "Tip: " + sanitize(it.tip), italics: true })],
                })
              );
            }
            if (it.kenyanContext) {
              bodyChildren.push(
                new Paragraph({
                  children: [new TextRun({ text: "Kenyan context: " + sanitize(it.kenyanContext) })],
                })
              );
            }
  
            // small spacer
            bodyChildren.push(new Paragraph({ text: "", spacing: { after: 80 } }));
          }
        }
      }
  
      // Closing suggestions / next steps if priorities exist
      if (analysis.marketReadiness?.priorities?.length) {
        bodyChildren.push(new Paragraph({ text: "Next Steps", heading: HeadingLevel.HEADING_2 }));
        for (const p of analysis.marketReadiness.priorities) {
          bodyChildren.push(new Paragraph({ children: [new TextRun({ text: "• " + sanitize(p) })] }));
        }
      }
  
      // Footer closing
      bodyChildren.push(
        new Paragraph({
          children: [new TextRun({ text: "Generated by Kazikit • Good luck!", italics: true })],
          spacing: { before: 200 },
        })
      );
  
      // Append body section
      doc.addSection({ children: bodyChildren });
  
      // Create Buffer
      const packed = await Packer.toBuffer(doc);
      return { buffer: Buffer.from(packed), filename };
    } catch (err: any) {
      const msg = err?.message ? `Failed to generate .docx: ${err.message}` : "Failed to generate .docx";
      throw new Error(msg);
    }
  }
  